/*
 * FINBOURNE Honeycomb Web API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.7.42
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.finbourne.luminesce.api;

import com.finbourne.luminesce.ApiCallback;
import com.finbourne.luminesce.ApiClient;
import com.finbourne.luminesce.ApiException;
import com.finbourne.luminesce.ApiResponse;
import com.finbourne.luminesce.Configuration;
import com.finbourne.luminesce.Pair;
import com.finbourne.luminesce.ProgressRequestBody;
import com.finbourne.luminesce.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.finbourne.luminesce.model.BackgroundQueryCancelResponse;
import com.finbourne.luminesce.model.BackgroundQueryProgressResponse;
import com.finbourne.luminesce.model.BackgroundQueryResponse;
import com.finbourne.luminesce.model.LusidProblemDetails;
import java.time.OffsetDateTime;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HistoricallyExecutedQueriesApi {
    private ApiClient localVarApiClient;
    public HistoricallyExecutedQueriesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public HistoricallyExecutedQueriesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for cancelHistory
     * @param executionId ExecutionId returned when starting the query (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelHistoryCall(String executionId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/History/{executionId}"
            .replaceAll("\\{" + "executionId" + "\\}", localVarApiClient.escapeString(executionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.7.42");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelHistoryValidateBeforeCall(String executionId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'executionId' is set
        if (executionId == null) {
            throw new ApiException("Missing the required parameter 'executionId' when calling cancelHistory(Async)");
        }
        

        okhttp3.Call localVarCall = cancelHistoryCall(executionId, _callback);
        return localVarCall;

    }

    /**
     * [EXPERIMENTAL] CancelHistory: Cancels (if running) or clears the data from (if completed) a previously started History query
     * Cancel the query (if still running) / clear the data (if already returned) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. 
     * @param executionId ExecutionId returned when starting the query (required)
     * @return BackgroundQueryCancelResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public BackgroundQueryCancelResponse cancelHistory(String executionId) throws ApiException {
        ApiResponse<BackgroundQueryCancelResponse> localVarResp = cancelHistoryWithHttpInfo(executionId);
        return localVarResp.getData();
    }

    /**
     * [EXPERIMENTAL] CancelHistory: Cancels (if running) or clears the data from (if completed) a previously started History query
     * Cancel the query (if still running) / clear the data (if already returned) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. 
     * @param executionId ExecutionId returned when starting the query (required)
     * @return ApiResponse&lt;BackgroundQueryCancelResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BackgroundQueryCancelResponse> cancelHistoryWithHttpInfo(String executionId) throws ApiException {
        okhttp3.Call localVarCall = cancelHistoryValidateBeforeCall(executionId, null);
        Type localVarReturnType = new TypeToken<BackgroundQueryCancelResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [EXPERIMENTAL] CancelHistory: Cancels (if running) or clears the data from (if completed) a previously started History query (asynchronously)
     * Cancel the query (if still running) / clear the data (if already returned) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. 
     * @param executionId ExecutionId returned when starting the query (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelHistoryAsync(String executionId, final ApiCallback<BackgroundQueryCancelResponse> _callback) throws ApiException {
        okhttp3.Call localVarCall = cancelHistoryValidateBeforeCall(executionId, _callback);
        Type localVarReturnType = new TypeToken<BackgroundQueryCancelResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fetchHistoryResultJson
     * @param executionId ExecutionId returned when starting the query (required)
     * @param sortBy Order the results by these fields.              Use the &#x60;-&#x60; sign to denote descending order, e.g. &#x60;-MyFieldName&#x60;.  Numeric indexes may be used also, e.g. &#x60;2,-3&#x60;.              Multiple fields can be denoted by a comma e.g. &#x60;-MyFieldName,AnotherFieldName,-AFurtherFieldName&#x60;.              Default is null, the sort order specified in the query itself. (optional)
     * @param filter An ODATA filter per Finbourne.Filtering syntax. (optional)
     * @param select Default is null (meaning return all columns in the original query itself).  The values are in terms of the result column name from the original data set and are comma delimited.  The power of this comes in that you may aggregate the data if you wish  (that is the main reason for allowing this, in fact).  e.g.:  - &#x60;MyField&#x60;  - &#x60;Max(x) FILTER (WHERE y &gt; 12) as ABC&#x60; (max of a field, if another field lets it qualify, with a nice column name)  - &#x60;count(*)&#x60; (count the rows for the given group, that would produce a rather ugly column name, but  it works)  - &#x60;count(distinct x) as numOfXs&#x60;  If there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ].   e.g.  - &#x60;some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name&#x60;    where you would likely want to pass &#x60;1&#x60; as the &#x60;groupBy&#x60; also. (optional)
     * @param groupBy Groups by the specified fields.              A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).              e.g. &#x60;2,3&#x60;, &#x60;myColumn&#x60;.              Default is null (meaning no grouping will be performed on the selected columns).              This applies only over the result set being requested here, meaning indexes into the \&quot;select\&quot; parameter fields.              Only specify this if you are selecting aggregations in the \&quot;select\&quot; parameter. (optional)
     * @param limit When paginating, only return this number of records, page should also be specified. (optional, default to 0)
     * @param page 0-N based on chunk sized determined by the limit, ignored if limit &lt; 1. (optional, default to 0)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fetchHistoryResultJsonCall(String executionId, String sortBy, String filter, String select, String groupBy, Integer limit, Integer page, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/History/{executionId}/json"
            .replaceAll("\\{" + "executionId" + "\\}", localVarApiClient.escapeString(executionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortBy", sortBy));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (select != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("select", select));
        }

        if (groupBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("groupBy", groupBy));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (jsonProper != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("jsonProper", jsonProper));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.7.42");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchHistoryResultJsonValidateBeforeCall(String executionId, String sortBy, String filter, String select, String groupBy, Integer limit, Integer page, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'executionId' is set
        if (executionId == null) {
            throw new ApiException("Missing the required parameter 'executionId' when calling fetchHistoryResultJson(Async)");
        }
        

        okhttp3.Call localVarCall = fetchHistoryResultJsonCall(executionId, sortBy, filter, select, groupBy, limit, page, jsonProper, _callback);
        return localVarCall;

    }

    /**
     * [EXPERIMENTAL] FetchHistoryResultJson: Fetches the result from a previously started query, in JSON format.
     * Fetch the data in Json format (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     * @param executionId ExecutionId returned when starting the query (required)
     * @param sortBy Order the results by these fields.              Use the &#x60;-&#x60; sign to denote descending order, e.g. &#x60;-MyFieldName&#x60;.  Numeric indexes may be used also, e.g. &#x60;2,-3&#x60;.              Multiple fields can be denoted by a comma e.g. &#x60;-MyFieldName,AnotherFieldName,-AFurtherFieldName&#x60;.              Default is null, the sort order specified in the query itself. (optional)
     * @param filter An ODATA filter per Finbourne.Filtering syntax. (optional)
     * @param select Default is null (meaning return all columns in the original query itself).  The values are in terms of the result column name from the original data set and are comma delimited.  The power of this comes in that you may aggregate the data if you wish  (that is the main reason for allowing this, in fact).  e.g.:  - &#x60;MyField&#x60;  - &#x60;Max(x) FILTER (WHERE y &gt; 12) as ABC&#x60; (max of a field, if another field lets it qualify, with a nice column name)  - &#x60;count(*)&#x60; (count the rows for the given group, that would produce a rather ugly column name, but  it works)  - &#x60;count(distinct x) as numOfXs&#x60;  If there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ].   e.g.  - &#x60;some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name&#x60;    where you would likely want to pass &#x60;1&#x60; as the &#x60;groupBy&#x60; also. (optional)
     * @param groupBy Groups by the specified fields.              A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).              e.g. &#x60;2,3&#x60;, &#x60;myColumn&#x60;.              Default is null (meaning no grouping will be performed on the selected columns).              This applies only over the result set being requested here, meaning indexes into the \&quot;select\&quot; parameter fields.              Only specify this if you are selecting aggregations in the \&quot;select\&quot; parameter. (optional)
     * @param limit When paginating, only return this number of records, page should also be specified. (optional, default to 0)
     * @param page 0-N based on chunk sized determined by the limit, ignored if limit &lt; 1. (optional, default to 0)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public String fetchHistoryResultJson(String executionId, String sortBy, String filter, String select, String groupBy, Integer limit, Integer page, Boolean jsonProper) throws ApiException {
        ApiResponse<String> localVarResp = fetchHistoryResultJsonWithHttpInfo(executionId, sortBy, filter, select, groupBy, limit, page, jsonProper);
        return localVarResp.getData();
    }

    /**
     * [EXPERIMENTAL] FetchHistoryResultJson: Fetches the result from a previously started query, in JSON format.
     * Fetch the data in Json format (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     * @param executionId ExecutionId returned when starting the query (required)
     * @param sortBy Order the results by these fields.              Use the &#x60;-&#x60; sign to denote descending order, e.g. &#x60;-MyFieldName&#x60;.  Numeric indexes may be used also, e.g. &#x60;2,-3&#x60;.              Multiple fields can be denoted by a comma e.g. &#x60;-MyFieldName,AnotherFieldName,-AFurtherFieldName&#x60;.              Default is null, the sort order specified in the query itself. (optional)
     * @param filter An ODATA filter per Finbourne.Filtering syntax. (optional)
     * @param select Default is null (meaning return all columns in the original query itself).  The values are in terms of the result column name from the original data set and are comma delimited.  The power of this comes in that you may aggregate the data if you wish  (that is the main reason for allowing this, in fact).  e.g.:  - &#x60;MyField&#x60;  - &#x60;Max(x) FILTER (WHERE y &gt; 12) as ABC&#x60; (max of a field, if another field lets it qualify, with a nice column name)  - &#x60;count(*)&#x60; (count the rows for the given group, that would produce a rather ugly column name, but  it works)  - &#x60;count(distinct x) as numOfXs&#x60;  If there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ].   e.g.  - &#x60;some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name&#x60;    where you would likely want to pass &#x60;1&#x60; as the &#x60;groupBy&#x60; also. (optional)
     * @param groupBy Groups by the specified fields.              A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).              e.g. &#x60;2,3&#x60;, &#x60;myColumn&#x60;.              Default is null (meaning no grouping will be performed on the selected columns).              This applies only over the result set being requested here, meaning indexes into the \&quot;select\&quot; parameter fields.              Only specify this if you are selecting aggregations in the \&quot;select\&quot; parameter. (optional)
     * @param limit When paginating, only return this number of records, page should also be specified. (optional, default to 0)
     * @param page 0-N based on chunk sized determined by the limit, ignored if limit &lt; 1. (optional, default to 0)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> fetchHistoryResultJsonWithHttpInfo(String executionId, String sortBy, String filter, String select, String groupBy, Integer limit, Integer page, Boolean jsonProper) throws ApiException {
        okhttp3.Call localVarCall = fetchHistoryResultJsonValidateBeforeCall(executionId, sortBy, filter, select, groupBy, limit, page, jsonProper, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [EXPERIMENTAL] FetchHistoryResultJson: Fetches the result from a previously started query, in JSON format. (asynchronously)
     * Fetch the data in Json format (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     * @param executionId ExecutionId returned when starting the query (required)
     * @param sortBy Order the results by these fields.              Use the &#x60;-&#x60; sign to denote descending order, e.g. &#x60;-MyFieldName&#x60;.  Numeric indexes may be used also, e.g. &#x60;2,-3&#x60;.              Multiple fields can be denoted by a comma e.g. &#x60;-MyFieldName,AnotherFieldName,-AFurtherFieldName&#x60;.              Default is null, the sort order specified in the query itself. (optional)
     * @param filter An ODATA filter per Finbourne.Filtering syntax. (optional)
     * @param select Default is null (meaning return all columns in the original query itself).  The values are in terms of the result column name from the original data set and are comma delimited.  The power of this comes in that you may aggregate the data if you wish  (that is the main reason for allowing this, in fact).  e.g.:  - &#x60;MyField&#x60;  - &#x60;Max(x) FILTER (WHERE y &gt; 12) as ABC&#x60; (max of a field, if another field lets it qualify, with a nice column name)  - &#x60;count(*)&#x60; (count the rows for the given group, that would produce a rather ugly column name, but  it works)  - &#x60;count(distinct x) as numOfXs&#x60;  If there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ].   e.g.  - &#x60;some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name&#x60;    where you would likely want to pass &#x60;1&#x60; as the &#x60;groupBy&#x60; also. (optional)
     * @param groupBy Groups by the specified fields.              A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).              e.g. &#x60;2,3&#x60;, &#x60;myColumn&#x60;.              Default is null (meaning no grouping will be performed on the selected columns).              This applies only over the result set being requested here, meaning indexes into the \&quot;select\&quot; parameter fields.              Only specify this if you are selecting aggregations in the \&quot;select\&quot; parameter. (optional)
     * @param limit When paginating, only return this number of records, page should also be specified. (optional, default to 0)
     * @param page 0-N based on chunk sized determined by the limit, ignored if limit &lt; 1. (optional, default to 0)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fetchHistoryResultJsonAsync(String executionId, String sortBy, String filter, String select, String groupBy, Integer limit, Integer page, Boolean jsonProper, final ApiCallback<String> _callback) throws ApiException {
        okhttp3.Call localVarCall = fetchHistoryResultJsonValidateBeforeCall(executionId, sortBy, filter, select, groupBy, limit, page, jsonProper, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fetchQueryResultHistogram
     * @param executionId ExecutionId returned when starting the query (required)
     * @param bucketSize Optional histogram bucket width.  If not provided a set number of buckets between start/end range will be generated. (optional)
     * @param filter An ODATA filter per Finbourne.Filtering syntax. (optional)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fetchQueryResultHistogramCall(String executionId, String bucketSize, String filter, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/History/{executionId}/histogram"
            .replaceAll("\\{" + "executionId" + "\\}", localVarApiClient.escapeString(executionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (bucketSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bucketSize", bucketSize));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (jsonProper != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("jsonProper", jsonProper));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.7.42");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchQueryResultHistogramValidateBeforeCall(String executionId, String bucketSize, String filter, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'executionId' is set
        if (executionId == null) {
            throw new ApiException("Missing the required parameter 'executionId' when calling fetchQueryResultHistogram(Async)");
        }
        

        okhttp3.Call localVarCall = fetchQueryResultHistogramCall(executionId, bucketSize, filter, jsonProper, _callback);
        return localVarCall;

    }

    /**
     * [EXPERIMENTAL] FetchQueryResultHistogram: Fetches the result from a previously started query, converts it to a histogram (counts in buckets).
     * Fetch the data in Json format (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     * @param executionId ExecutionId returned when starting the query (required)
     * @param bucketSize Optional histogram bucket width.  If not provided a set number of buckets between start/end range will be generated. (optional)
     * @param filter An ODATA filter per Finbourne.Filtering syntax. (optional)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public String fetchQueryResultHistogram(String executionId, String bucketSize, String filter, Boolean jsonProper) throws ApiException {
        ApiResponse<String> localVarResp = fetchQueryResultHistogramWithHttpInfo(executionId, bucketSize, filter, jsonProper);
        return localVarResp.getData();
    }

    /**
     * [EXPERIMENTAL] FetchQueryResultHistogram: Fetches the result from a previously started query, converts it to a histogram (counts in buckets).
     * Fetch the data in Json format (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     * @param executionId ExecutionId returned when starting the query (required)
     * @param bucketSize Optional histogram bucket width.  If not provided a set number of buckets between start/end range will be generated. (optional)
     * @param filter An ODATA filter per Finbourne.Filtering syntax. (optional)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> fetchQueryResultHistogramWithHttpInfo(String executionId, String bucketSize, String filter, Boolean jsonProper) throws ApiException {
        okhttp3.Call localVarCall = fetchQueryResultHistogramValidateBeforeCall(executionId, bucketSize, filter, jsonProper, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [EXPERIMENTAL] FetchQueryResultHistogram: Fetches the result from a previously started query, converts it to a histogram (counts in buckets). (asynchronously)
     * Fetch the data in Json format (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     * @param executionId ExecutionId returned when starting the query (required)
     * @param bucketSize Optional histogram bucket width.  If not provided a set number of buckets between start/end range will be generated. (optional)
     * @param filter An ODATA filter per Finbourne.Filtering syntax. (optional)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fetchQueryResultHistogramAsync(String executionId, String bucketSize, String filter, Boolean jsonProper, final ApiCallback<String> _callback) throws ApiException {
        okhttp3.Call localVarCall = fetchQueryResultHistogramValidateBeforeCall(executionId, bucketSize, filter, jsonProper, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getHistory
     * @param startAt Date time to start the search from.  Will default to Now - 1 Day (optional)
     * @param endAt Date time to end the search at.  Defaults to now. (optional)
     * @param freeTextSearch Some test that must be in at least one field returned. (optional)
     * @param showAll For users with extra permissions, they may optionally see other users&#39; queries. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getHistoryCall(OffsetDateTime startAt, OffsetDateTime endAt, String freeTextSearch, Boolean showAll, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/History";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (startAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startAt", startAt));
        }

        if (endAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endAt", endAt));
        }

        if (freeTextSearch != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("freeTextSearch", freeTextSearch));
        }

        if (showAll != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("showAll", showAll));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.7.42");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getHistoryValidateBeforeCall(OffsetDateTime startAt, OffsetDateTime endAt, String freeTextSearch, Boolean showAll, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getHistoryCall(startAt, endAt, freeTextSearch, showAll, _callback);
        return localVarCall;

    }

    /**
     * [EXPERIMENTAL] GetHistory: Shows queries executed in a given historical time window (in Json format).
     *  Starts to load the historical query logs for a certain time range, search criteria, etc.  The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized 
     * @param startAt Date time to start the search from.  Will default to Now - 1 Day (optional)
     * @param endAt Date time to end the search at.  Defaults to now. (optional)
     * @param freeTextSearch Some test that must be in at least one field returned. (optional)
     * @param showAll For users with extra permissions, they may optionally see other users&#39; queries. (optional, default to false)
     * @return BackgroundQueryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public BackgroundQueryResponse getHistory(OffsetDateTime startAt, OffsetDateTime endAt, String freeTextSearch, Boolean showAll) throws ApiException {
        ApiResponse<BackgroundQueryResponse> localVarResp = getHistoryWithHttpInfo(startAt, endAt, freeTextSearch, showAll);
        return localVarResp.getData();
    }

    /**
     * [EXPERIMENTAL] GetHistory: Shows queries executed in a given historical time window (in Json format).
     *  Starts to load the historical query logs for a certain time range, search criteria, etc.  The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized 
     * @param startAt Date time to start the search from.  Will default to Now - 1 Day (optional)
     * @param endAt Date time to end the search at.  Defaults to now. (optional)
     * @param freeTextSearch Some test that must be in at least one field returned. (optional)
     * @param showAll For users with extra permissions, they may optionally see other users&#39; queries. (optional, default to false)
     * @return ApiResponse&lt;BackgroundQueryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BackgroundQueryResponse> getHistoryWithHttpInfo(OffsetDateTime startAt, OffsetDateTime endAt, String freeTextSearch, Boolean showAll) throws ApiException {
        okhttp3.Call localVarCall = getHistoryValidateBeforeCall(startAt, endAt, freeTextSearch, showAll, null);
        Type localVarReturnType = new TypeToken<BackgroundQueryResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [EXPERIMENTAL] GetHistory: Shows queries executed in a given historical time window (in Json format). (asynchronously)
     *  Starts to load the historical query logs for a certain time range, search criteria, etc.  The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized 
     * @param startAt Date time to start the search from.  Will default to Now - 1 Day (optional)
     * @param endAt Date time to end the search at.  Defaults to now. (optional)
     * @param freeTextSearch Some test that must be in at least one field returned. (optional)
     * @param showAll For users with extra permissions, they may optionally see other users&#39; queries. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getHistoryAsync(OffsetDateTime startAt, OffsetDateTime endAt, String freeTextSearch, Boolean showAll, final ApiCallback<BackgroundQueryResponse> _callback) throws ApiException {
        okhttp3.Call localVarCall = getHistoryValidateBeforeCall(startAt, endAt, freeTextSearch, showAll, _callback);
        Type localVarReturnType = new TypeToken<BackgroundQueryResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getProgressOfHistory
     * @param executionId ExecutionId returned when starting the query (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getProgressOfHistoryCall(String executionId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/History/{executionId}"
            .replaceAll("\\{" + "executionId" + "\\}", localVarApiClient.escapeString(executionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.7.42");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getProgressOfHistoryValidateBeforeCall(String executionId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'executionId' is set
        if (executionId == null) {
            throw new ApiException("Missing the required parameter 'executionId' when calling getProgressOfHistory(Async)");
        }
        

        okhttp3.Call localVarCall = getProgressOfHistoryCall(executionId, _callback);
        return localVarCall;

    }

    /**
     * [EXPERIMENTAL] GetProgressOfHistory: View progress information (up until this point) of a history query
     * View progress information (up until this point) of previously started History query The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     * @param executionId ExecutionId returned when starting the query (required)
     * @return BackgroundQueryProgressResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public BackgroundQueryProgressResponse getProgressOfHistory(String executionId) throws ApiException {
        ApiResponse<BackgroundQueryProgressResponse> localVarResp = getProgressOfHistoryWithHttpInfo(executionId);
        return localVarResp.getData();
    }

    /**
     * [EXPERIMENTAL] GetProgressOfHistory: View progress information (up until this point) of a history query
     * View progress information (up until this point) of previously started History query The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     * @param executionId ExecutionId returned when starting the query (required)
     * @return ApiResponse&lt;BackgroundQueryProgressResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BackgroundQueryProgressResponse> getProgressOfHistoryWithHttpInfo(String executionId) throws ApiException {
        okhttp3.Call localVarCall = getProgressOfHistoryValidateBeforeCall(executionId, null);
        Type localVarReturnType = new TypeToken<BackgroundQueryProgressResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [EXPERIMENTAL] GetProgressOfHistory: View progress information (up until this point) of a history query (asynchronously)
     * View progress information (up until this point) of previously started History query The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     * @param executionId ExecutionId returned when starting the query (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getProgressOfHistoryAsync(String executionId, final ApiCallback<BackgroundQueryProgressResponse> _callback) throws ApiException {
        okhttp3.Call localVarCall = getProgressOfHistoryValidateBeforeCall(executionId, _callback);
        Type localVarReturnType = new TypeToken<BackgroundQueryProgressResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
