/*
 * FINBOURNE Luminesce Web API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.11.201
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.finbourne.luminesce.api;

import com.finbourne.luminesce.ApiCallback;
import com.finbourne.luminesce.ApiClient;
import com.finbourne.luminesce.ApiException;
import com.finbourne.luminesce.ApiResponse;
import com.finbourne.luminesce.Configuration;
import com.finbourne.luminesce.Pair;
import com.finbourne.luminesce.ProgressRequestBody;
import com.finbourne.luminesce.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.finbourne.luminesce.model.LusidProblemDetails;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SqlExecutionApi {
    private ApiClient localVarApiClient;
    public SqlExecutionApi() {
        this(Configuration.getDefaultApiClient());
    }

    public SqlExecutionApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for getByQueryCsv
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getByQueryCsvCall(String query, String queryName, Boolean download, Integer timeout, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/Sql/csv/{query}"
            .replaceAll("\\{" + "query" + "\\}", localVarApiClient.escapeString(query.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (download != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("download", download));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.11.201");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByQueryCsvValidateBeforeCall(String query, String queryName, Boolean download, Integer timeout, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling getByQueryCsv(Async)");
        }
        

        okhttp3.Call localVarCall = getByQueryCsvCall(query, queryName, download, timeout, _callback);
        return localVarCall;

    }

    /**
     * GetByQueryCsv: Executes Sql, returned in CSV format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public String getByQueryCsv(String query, String queryName, Boolean download, Integer timeout) throws ApiException {
        ApiResponse<String> localVarResp = getByQueryCsvWithHttpInfo(query, queryName, download, timeout);
        return localVarResp.getData();
    }

    /**
     * GetByQueryCsv: Executes Sql, returned in CSV format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> getByQueryCsvWithHttpInfo(String query, String queryName, Boolean download, Integer timeout) throws ApiException {
        okhttp3.Call localVarCall = getByQueryCsvValidateBeforeCall(query, queryName, download, timeout, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * GetByQueryCsv: Executes Sql, returned in CSV format, where the sql is simply in the url. (asynchronously)
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getByQueryCsvAsync(String query, String queryName, Boolean download, Integer timeout, final ApiCallback<String> _callback) throws ApiException {
        okhttp3.Call localVarCall = getByQueryCsvValidateBeforeCall(query, queryName, download, timeout, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getByQueryExcel
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getByQueryExcelCall(String query, String queryName, Integer timeout, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/Sql/excel/{query}"
            .replaceAll("\\{" + "query" + "\\}", localVarApiClient.escapeString(query.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.11.201");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByQueryExcelValidateBeforeCall(String query, String queryName, Integer timeout, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling getByQueryExcel(Async)");
        }
        

        okhttp3.Call localVarCall = getByQueryExcelCall(query, queryName, timeout, _callback);
        return localVarCall;

    }

    /**
     * GetByQueryExcel: Executes Sql, returned in Excel (xlsx) format (as a file to be downloaded) format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public String getByQueryExcel(String query, String queryName, Integer timeout) throws ApiException {
        ApiResponse<String> localVarResp = getByQueryExcelWithHttpInfo(query, queryName, timeout);
        return localVarResp.getData();
    }

    /**
     * GetByQueryExcel: Executes Sql, returned in Excel (xlsx) format (as a file to be downloaded) format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> getByQueryExcelWithHttpInfo(String query, String queryName, Integer timeout) throws ApiException {
        okhttp3.Call localVarCall = getByQueryExcelValidateBeforeCall(query, queryName, timeout, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * GetByQueryExcel: Executes Sql, returned in Excel (xlsx) format (as a file to be downloaded) format, where the sql is simply in the url. (asynchronously)
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getByQueryExcelAsync(String query, String queryName, Integer timeout, final ApiCallback<String> _callback) throws ApiException {
        okhttp3.Call localVarCall = getByQueryExcelValidateBeforeCall(query, queryName, timeout, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getByQueryJson
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getByQueryJsonCall(String query, String queryName, Integer timeout, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/Sql/json/{query}"
            .replaceAll("\\{" + "query" + "\\}", localVarApiClient.escapeString(query.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        if (jsonProper != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("jsonProper", jsonProper));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.11.201");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByQueryJsonValidateBeforeCall(String query, String queryName, Integer timeout, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling getByQueryJson(Async)");
        }
        

        okhttp3.Call localVarCall = getByQueryJsonCall(query, queryName, timeout, jsonProper, _callback);
        return localVarCall;

    }

    /**
     * GetByQueryJson: Executes Sql, returned in JSON format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public String getByQueryJson(String query, String queryName, Integer timeout, Boolean jsonProper) throws ApiException {
        ApiResponse<String> localVarResp = getByQueryJsonWithHttpInfo(query, queryName, timeout, jsonProper);
        return localVarResp.getData();
    }

    /**
     * GetByQueryJson: Executes Sql, returned in JSON format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> getByQueryJsonWithHttpInfo(String query, String queryName, Integer timeout, Boolean jsonProper) throws ApiException {
        okhttp3.Call localVarCall = getByQueryJsonValidateBeforeCall(query, queryName, timeout, jsonProper, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * GetByQueryJson: Executes Sql, returned in JSON format, where the sql is simply in the url. (asynchronously)
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getByQueryJsonAsync(String query, String queryName, Integer timeout, Boolean jsonProper, final ApiCallback<String> _callback) throws ApiException {
        okhttp3.Call localVarCall = getByQueryJsonValidateBeforeCall(query, queryName, timeout, jsonProper, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getByQueryPipe
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getByQueryPipeCall(String query, String queryName, Boolean download, Integer timeout, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/Sql/pipe/{query}"
            .replaceAll("\\{" + "query" + "\\}", localVarApiClient.escapeString(query.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (download != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("download", download));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.11.201");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByQueryPipeValidateBeforeCall(String query, String queryName, Boolean download, Integer timeout, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling getByQueryPipe(Async)");
        }
        

        okhttp3.Call localVarCall = getByQueryPipeCall(query, queryName, download, timeout, _callback);
        return localVarCall;

    }

    /**
     * GetByQueryPipe: Executes Sql, returned in pipe-delimited format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public String getByQueryPipe(String query, String queryName, Boolean download, Integer timeout) throws ApiException {
        ApiResponse<String> localVarResp = getByQueryPipeWithHttpInfo(query, queryName, download, timeout);
        return localVarResp.getData();
    }

    /**
     * GetByQueryPipe: Executes Sql, returned in pipe-delimited format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> getByQueryPipeWithHttpInfo(String query, String queryName, Boolean download, Integer timeout) throws ApiException {
        okhttp3.Call localVarCall = getByQueryPipeValidateBeforeCall(query, queryName, download, timeout, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * GetByQueryPipe: Executes Sql, returned in pipe-delimited format, where the sql is simply in the url. (asynchronously)
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getByQueryPipeAsync(String query, String queryName, Boolean download, Integer timeout, final ApiCallback<String> _callback) throws ApiException {
        okhttp3.Call localVarCall = getByQueryPipeValidateBeforeCall(query, queryName, download, timeout, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getByQuerySqlite
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getByQuerySqliteCall(String query, String queryName, Integer timeout, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/Sql/sqlite/{query}"
            .replaceAll("\\{" + "query" + "\\}", localVarApiClient.escapeString(query.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.11.201");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByQuerySqliteValidateBeforeCall(String query, String queryName, Integer timeout, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling getByQuerySqlite(Async)");
        }
        

        okhttp3.Call localVarCall = getByQuerySqliteCall(query, queryName, timeout, _callback);
        return localVarCall;

    }

    /**
     * GetByQuerySqlite: Executes Sql, returned in SqLite DB (sqlite3) format (as a file to be downloaded) format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public String getByQuerySqlite(String query, String queryName, Integer timeout) throws ApiException {
        ApiResponse<String> localVarResp = getByQuerySqliteWithHttpInfo(query, queryName, timeout);
        return localVarResp.getData();
    }

    /**
     * GetByQuerySqlite: Executes Sql, returned in SqLite DB (sqlite3) format (as a file to be downloaded) format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> getByQuerySqliteWithHttpInfo(String query, String queryName, Integer timeout) throws ApiException {
        okhttp3.Call localVarCall = getByQuerySqliteValidateBeforeCall(query, queryName, timeout, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * GetByQuerySqlite: Executes Sql, returned in SqLite DB (sqlite3) format (as a file to be downloaded) format, where the sql is simply in the url. (asynchronously)
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getByQuerySqliteAsync(String query, String queryName, Integer timeout, final ApiCallback<String> _callback) throws ApiException {
        okhttp3.Call localVarCall = getByQuerySqliteValidateBeforeCall(query, queryName, timeout, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for putByQueryCsv
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call putByQueryCsvCall(String body, String queryName, Boolean download, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/csv";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (download != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("download", download));
        }

        if (timeoutSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeoutSeconds", timeoutSeconds));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.11.201");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putByQueryCsvValidateBeforeCall(String body, String queryName, Boolean download, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putByQueryCsv(Async)");
        }
        

        okhttp3.Call localVarCall = putByQueryCsvCall(body, queryName, download, timeoutSeconds, _callback);
        return localVarCall;

    }

    /**
     * PutByQueryCsv: Executes Sql, returned in CSV format, where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public String putByQueryCsv(String body, String queryName, Boolean download, Integer timeoutSeconds) throws ApiException {
        ApiResponse<String> localVarResp = putByQueryCsvWithHttpInfo(body, queryName, download, timeoutSeconds);
        return localVarResp.getData();
    }

    /**
     * PutByQueryCsv: Executes Sql, returned in CSV format, where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> putByQueryCsvWithHttpInfo(String body, String queryName, Boolean download, Integer timeoutSeconds) throws ApiException {
        okhttp3.Call localVarCall = putByQueryCsvValidateBeforeCall(body, queryName, download, timeoutSeconds, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * PutByQueryCsv: Executes Sql, returned in CSV format, where the sql is the post-body url. (asynchronously)
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call putByQueryCsvAsync(String body, String queryName, Boolean download, Integer timeoutSeconds, final ApiCallback<String> _callback) throws ApiException {
        okhttp3.Call localVarCall = putByQueryCsvValidateBeforeCall(body, queryName, download, timeoutSeconds, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for putByQueryExcel
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call putByQueryExcelCall(String body, String queryName, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/excel";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeoutSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeoutSeconds", timeoutSeconds));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.11.201");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putByQueryExcelValidateBeforeCall(String body, String queryName, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putByQueryExcel(Async)");
        }
        

        okhttp3.Call localVarCall = putByQueryExcelCall(body, queryName, timeoutSeconds, _callback);
        return localVarCall;

    }

    /**
     * PutByQueryExcel: Executes Sql, returned in Excel (xlsx) format (as a file to be downloaded), where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public String putByQueryExcel(String body, String queryName, Integer timeoutSeconds) throws ApiException {
        ApiResponse<String> localVarResp = putByQueryExcelWithHttpInfo(body, queryName, timeoutSeconds);
        return localVarResp.getData();
    }

    /**
     * PutByQueryExcel: Executes Sql, returned in Excel (xlsx) format (as a file to be downloaded), where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> putByQueryExcelWithHttpInfo(String body, String queryName, Integer timeoutSeconds) throws ApiException {
        okhttp3.Call localVarCall = putByQueryExcelValidateBeforeCall(body, queryName, timeoutSeconds, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * PutByQueryExcel: Executes Sql, returned in Excel (xlsx) format (as a file to be downloaded), where the sql is the post-body url. (asynchronously)
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call putByQueryExcelAsync(String body, String queryName, Integer timeoutSeconds, final ApiCallback<String> _callback) throws ApiException {
        okhttp3.Call localVarCall = putByQueryExcelValidateBeforeCall(body, queryName, timeoutSeconds, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for putByQueryJson
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call putByQueryJsonCall(String body, String queryName, Integer timeoutSeconds, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/json";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeoutSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeoutSeconds", timeoutSeconds));
        }

        if (jsonProper != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("jsonProper", jsonProper));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.11.201");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putByQueryJsonValidateBeforeCall(String body, String queryName, Integer timeoutSeconds, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putByQueryJson(Async)");
        }
        

        okhttp3.Call localVarCall = putByQueryJsonCall(body, queryName, timeoutSeconds, jsonProper, _callback);
        return localVarCall;

    }

    /**
     * PutByQueryJson: Executes Sql, returned in JSON format, where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public String putByQueryJson(String body, String queryName, Integer timeoutSeconds, Boolean jsonProper) throws ApiException {
        ApiResponse<String> localVarResp = putByQueryJsonWithHttpInfo(body, queryName, timeoutSeconds, jsonProper);
        return localVarResp.getData();
    }

    /**
     * PutByQueryJson: Executes Sql, returned in JSON format, where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> putByQueryJsonWithHttpInfo(String body, String queryName, Integer timeoutSeconds, Boolean jsonProper) throws ApiException {
        okhttp3.Call localVarCall = putByQueryJsonValidateBeforeCall(body, queryName, timeoutSeconds, jsonProper, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * PutByQueryJson: Executes Sql, returned in JSON format, where the sql is the post-body url. (asynchronously)
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call putByQueryJsonAsync(String body, String queryName, Integer timeoutSeconds, Boolean jsonProper, final ApiCallback<String> _callback) throws ApiException {
        okhttp3.Call localVarCall = putByQueryJsonValidateBeforeCall(body, queryName, timeoutSeconds, jsonProper, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for putByQueryPipe
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call putByQueryPipeCall(String body, String queryName, Boolean download, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/pipe";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (download != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("download", download));
        }

        if (timeoutSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeoutSeconds", timeoutSeconds));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.11.201");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putByQueryPipeValidateBeforeCall(String body, String queryName, Boolean download, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putByQueryPipe(Async)");
        }
        

        okhttp3.Call localVarCall = putByQueryPipeCall(body, queryName, download, timeoutSeconds, _callback);
        return localVarCall;

    }

    /**
     * PutByQueryPipe: Executes Sql, returned in pipe-delimited format, where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public String putByQueryPipe(String body, String queryName, Boolean download, Integer timeoutSeconds) throws ApiException {
        ApiResponse<String> localVarResp = putByQueryPipeWithHttpInfo(body, queryName, download, timeoutSeconds);
        return localVarResp.getData();
    }

    /**
     * PutByQueryPipe: Executes Sql, returned in pipe-delimited format, where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> putByQueryPipeWithHttpInfo(String body, String queryName, Boolean download, Integer timeoutSeconds) throws ApiException {
        okhttp3.Call localVarCall = putByQueryPipeValidateBeforeCall(body, queryName, download, timeoutSeconds, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * PutByQueryPipe: Executes Sql, returned in pipe-delimited format, where the sql is the post-body url. (asynchronously)
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call putByQueryPipeAsync(String body, String queryName, Boolean download, Integer timeoutSeconds, final ApiCallback<String> _callback) throws ApiException {
        okhttp3.Call localVarCall = putByQueryPipeValidateBeforeCall(body, queryName, download, timeoutSeconds, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for putByQuerySqlite
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call putByQuerySqliteCall(String body, String queryName, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/sqlite";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeoutSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeoutSeconds", timeoutSeconds));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.11.201");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putByQuerySqliteValidateBeforeCall(String body, String queryName, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putByQuerySqlite(Async)");
        }
        

        okhttp3.Call localVarCall = putByQuerySqliteCall(body, queryName, timeoutSeconds, _callback);
        return localVarCall;

    }

    /**
     * PutByQuerySqlite: Executes Sql, returned in SqLite DB (sqlite3) format (as a file to be downloaded), where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public String putByQuerySqlite(String body, String queryName, Integer timeoutSeconds) throws ApiException {
        ApiResponse<String> localVarResp = putByQuerySqliteWithHttpInfo(body, queryName, timeoutSeconds);
        return localVarResp.getData();
    }

    /**
     * PutByQuerySqlite: Executes Sql, returned in SqLite DB (sqlite3) format (as a file to be downloaded), where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> putByQuerySqliteWithHttpInfo(String body, String queryName, Integer timeoutSeconds) throws ApiException {
        okhttp3.Call localVarCall = putByQuerySqliteValidateBeforeCall(body, queryName, timeoutSeconds, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * PutByQuerySqlite: Executes Sql, returned in SqLite DB (sqlite3) format (as a file to be downloaded), where the sql is the post-body url. (asynchronously)
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li     on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
     * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call putByQuerySqliteAsync(String body, String queryName, Integer timeoutSeconds, final ApiCallback<String> _callback) throws ApiException {
        okhttp3.Call localVarCall = putByQuerySqliteValidateBeforeCall(body, queryName, timeoutSeconds, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for putQueryToFormat
     * @param body LuminesceSql to Pretty-Print. Even if it doesn&#39;t parse an attempt will be made to format it (required)
     * @param trailingCommas Should commas be after an expression (as opposed to before) (optional, default to true)
     * @param uppercaseKeywords Should key words be capitalized (optional, default to false)
     * @param breakJoinOnSections Should clauses on joins be given line breaks? (optional, default to true)
     * @param spaceAfterExpandedComma Should comma-lists have spaces after the commas? (optional, default to true)
     * @param keywordStandardization Should the \&quot;nicest\&quot; key words be used? (e.g. JOIN -&gt; INNER JOIN) (optional, default to true)
     * @param expandCommaLists Should comma-lists (e.g. select a,b,c) have line breaks added? (optional, default to false)
     * @param expandInLists Should IN-lists have line breaks added? (optional, default to false)
     * @param expandBooleanExpressions Should boolean expressions have line breaks added? (optional, default to true)
     * @param expandBetweenConditions Should between conditions have line breaks added? (optional, default to true)
     * @param expandCaseStatements Should case-statements have line breaks added? (optional, default to true)
     * @param maxLineWidth Maximum number of characters to allow on one line (if possible) (optional, default to 120)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call putQueryToFormatCall(String body, Boolean trailingCommas, Boolean uppercaseKeywords, Boolean breakJoinOnSections, Boolean spaceAfterExpandedComma, Boolean keywordStandardization, Boolean expandCommaLists, Boolean expandInLists, Boolean expandBooleanExpressions, Boolean expandBetweenConditions, Boolean expandCaseStatements, Integer maxLineWidth, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/pretty";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trailingCommas != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("trailingCommas", trailingCommas));
        }

        if (uppercaseKeywords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("uppercaseKeywords", uppercaseKeywords));
        }

        if (breakJoinOnSections != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("breakJoinOnSections", breakJoinOnSections));
        }

        if (spaceAfterExpandedComma != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("spaceAfterExpandedComma", spaceAfterExpandedComma));
        }

        if (keywordStandardization != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("keywordStandardization", keywordStandardization));
        }

        if (expandCommaLists != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandCommaLists", expandCommaLists));
        }

        if (expandInLists != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandInLists", expandInLists));
        }

        if (expandBooleanExpressions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandBooleanExpressions", expandBooleanExpressions));
        }

        if (expandBetweenConditions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandBetweenConditions", expandBetweenConditions));
        }

        if (expandCaseStatements != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandCaseStatements", expandCaseStatements));
        }

        if (maxLineWidth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxLineWidth", maxLineWidth));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        localVarHeaderParams.put("X-LUSID-SDK-Language", "Java");
        localVarHeaderParams.put("X-LUSID-SDK-Version", "1.11.201");

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putQueryToFormatValidateBeforeCall(String body, Boolean trailingCommas, Boolean uppercaseKeywords, Boolean breakJoinOnSections, Boolean spaceAfterExpandedComma, Boolean keywordStandardization, Boolean expandCommaLists, Boolean expandInLists, Boolean expandBooleanExpressions, Boolean expandBetweenConditions, Boolean expandCaseStatements, Integer maxLineWidth, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putQueryToFormat(Async)");
        }
        

        okhttp3.Call localVarCall = putQueryToFormatCall(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, _callback);
        return localVarCall;

    }

    /**
     * PutQueryToFormat: Executes Sql, returned in JSON format, where the sql is the post-body url.
     *  This formats SQL (given a set of options as to how to do so). It takes some SQL (or a fragment thereof, it need not fully parse as yet and certainly need not execute correctly) and returns the reformatted version. e.g. &#x60;&#x60;&#x60;sql select x,y,z from a inner join b on a.x&#x3D;b.x where x&gt;y or y!&#x3D;z &#x60;&#x60;&#x60; becomes &#x60;&#x60;&#x60;sql select x, y, z from a inner join b    on a.x &#x3D; b.x where x &gt; y    or y !&#x3D; z &#x60;&#x60;&#x60; 
     * @param body LuminesceSql to Pretty-Print. Even if it doesn&#39;t parse an attempt will be made to format it (required)
     * @param trailingCommas Should commas be after an expression (as opposed to before) (optional, default to true)
     * @param uppercaseKeywords Should key words be capitalized (optional, default to false)
     * @param breakJoinOnSections Should clauses on joins be given line breaks? (optional, default to true)
     * @param spaceAfterExpandedComma Should comma-lists have spaces after the commas? (optional, default to true)
     * @param keywordStandardization Should the \&quot;nicest\&quot; key words be used? (e.g. JOIN -&gt; INNER JOIN) (optional, default to true)
     * @param expandCommaLists Should comma-lists (e.g. select a,b,c) have line breaks added? (optional, default to false)
     * @param expandInLists Should IN-lists have line breaks added? (optional, default to false)
     * @param expandBooleanExpressions Should boolean expressions have line breaks added? (optional, default to true)
     * @param expandBetweenConditions Should between conditions have line breaks added? (optional, default to true)
     * @param expandCaseStatements Should case-statements have line breaks added? (optional, default to true)
     * @param maxLineWidth Maximum number of characters to allow on one line (if possible) (optional, default to 120)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public String putQueryToFormat(String body, Boolean trailingCommas, Boolean uppercaseKeywords, Boolean breakJoinOnSections, Boolean spaceAfterExpandedComma, Boolean keywordStandardization, Boolean expandCommaLists, Boolean expandInLists, Boolean expandBooleanExpressions, Boolean expandBetweenConditions, Boolean expandCaseStatements, Integer maxLineWidth) throws ApiException {
        ApiResponse<String> localVarResp = putQueryToFormatWithHttpInfo(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth);
        return localVarResp.getData();
    }

    /**
     * PutQueryToFormat: Executes Sql, returned in JSON format, where the sql is the post-body url.
     *  This formats SQL (given a set of options as to how to do so). It takes some SQL (or a fragment thereof, it need not fully parse as yet and certainly need not execute correctly) and returns the reformatted version. e.g. &#x60;&#x60;&#x60;sql select x,y,z from a inner join b on a.x&#x3D;b.x where x&gt;y or y!&#x3D;z &#x60;&#x60;&#x60; becomes &#x60;&#x60;&#x60;sql select x, y, z from a inner join b    on a.x &#x3D; b.x where x &gt; y    or y !&#x3D; z &#x60;&#x60;&#x60; 
     * @param body LuminesceSql to Pretty-Print. Even if it doesn&#39;t parse an attempt will be made to format it (required)
     * @param trailingCommas Should commas be after an expression (as opposed to before) (optional, default to true)
     * @param uppercaseKeywords Should key words be capitalized (optional, default to false)
     * @param breakJoinOnSections Should clauses on joins be given line breaks? (optional, default to true)
     * @param spaceAfterExpandedComma Should comma-lists have spaces after the commas? (optional, default to true)
     * @param keywordStandardization Should the \&quot;nicest\&quot; key words be used? (e.g. JOIN -&gt; INNER JOIN) (optional, default to true)
     * @param expandCommaLists Should comma-lists (e.g. select a,b,c) have line breaks added? (optional, default to false)
     * @param expandInLists Should IN-lists have line breaks added? (optional, default to false)
     * @param expandBooleanExpressions Should boolean expressions have line breaks added? (optional, default to true)
     * @param expandBetweenConditions Should between conditions have line breaks added? (optional, default to true)
     * @param expandCaseStatements Should case-statements have line breaks added? (optional, default to true)
     * @param maxLineWidth Maximum number of characters to allow on one line (if possible) (optional, default to 120)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> putQueryToFormatWithHttpInfo(String body, Boolean trailingCommas, Boolean uppercaseKeywords, Boolean breakJoinOnSections, Boolean spaceAfterExpandedComma, Boolean keywordStandardization, Boolean expandCommaLists, Boolean expandInLists, Boolean expandBooleanExpressions, Boolean expandBetweenConditions, Boolean expandCaseStatements, Integer maxLineWidth) throws ApiException {
        okhttp3.Call localVarCall = putQueryToFormatValidateBeforeCall(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * PutQueryToFormat: Executes Sql, returned in JSON format, where the sql is the post-body url. (asynchronously)
     *  This formats SQL (given a set of options as to how to do so). It takes some SQL (or a fragment thereof, it need not fully parse as yet and certainly need not execute correctly) and returns the reformatted version. e.g. &#x60;&#x60;&#x60;sql select x,y,z from a inner join b on a.x&#x3D;b.x where x&gt;y or y!&#x3D;z &#x60;&#x60;&#x60; becomes &#x60;&#x60;&#x60;sql select x, y, z from a inner join b    on a.x &#x3D; b.x where x &gt; y    or y !&#x3D; z &#x60;&#x60;&#x60; 
     * @param body LuminesceSql to Pretty-Print. Even if it doesn&#39;t parse an attempt will be made to format it (required)
     * @param trailingCommas Should commas be after an expression (as opposed to before) (optional, default to true)
     * @param uppercaseKeywords Should key words be capitalized (optional, default to false)
     * @param breakJoinOnSections Should clauses on joins be given line breaks? (optional, default to true)
     * @param spaceAfterExpandedComma Should comma-lists have spaces after the commas? (optional, default to true)
     * @param keywordStandardization Should the \&quot;nicest\&quot; key words be used? (e.g. JOIN -&gt; INNER JOIN) (optional, default to true)
     * @param expandCommaLists Should comma-lists (e.g. select a,b,c) have line breaks added? (optional, default to false)
     * @param expandInLists Should IN-lists have line breaks added? (optional, default to false)
     * @param expandBooleanExpressions Should boolean expressions have line breaks added? (optional, default to true)
     * @param expandBetweenConditions Should between conditions have line breaks added? (optional, default to true)
     * @param expandCaseStatements Should case-statements have line breaks added? (optional, default to true)
     * @param maxLineWidth Maximum number of characters to allow on one line (if possible) (optional, default to 120)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call putQueryToFormatAsync(String body, Boolean trailingCommas, Boolean uppercaseKeywords, Boolean breakJoinOnSections, Boolean spaceAfterExpandedComma, Boolean keywordStandardization, Boolean expandCommaLists, Boolean expandInLists, Boolean expandBooleanExpressions, Boolean expandBetweenConditions, Boolean expandCaseStatements, Integer maxLineWidth, final ApiCallback<String> _callback) throws ApiException {
        okhttp3.Call localVarCall = putQueryToFormatValidateBeforeCall(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
