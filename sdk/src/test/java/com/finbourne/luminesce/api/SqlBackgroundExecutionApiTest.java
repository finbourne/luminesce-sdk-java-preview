/*
 * FINBOURNE Honeycomb Web API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.7.42
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.finbourne.luminesce.api;

import com.finbourne.luminesce.ApiException;
import com.finbourne.luminesce.model.BackgroundQueryCancelResponse;
import com.finbourne.luminesce.model.BackgroundQueryProgressResponse;
import com.finbourne.luminesce.model.BackgroundQueryResponse;
import com.finbourne.luminesce.model.LusidProblemDetails;
import org.junit.Test;
import org.junit.Ignore;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for SqlBackgroundExecutionApi
 */
@Ignore
public class SqlBackgroundExecutionApiTest {

    private final SqlBackgroundExecutionApi api = new SqlBackgroundExecutionApi();

    
    /**
     * [EXPERIMENTAL] CancelQuery: Cancels (if running) or clears the data from (if completed) a previously started query
     *
     * Cancel the query (if still running) / clear the data (if already returned) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void cancelQueryTest() throws ApiException {
        String executionId = null;
        BackgroundQueryCancelResponse response = api.cancelQuery(executionId);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] FetchQueryResultCsv: Fetches the result from a previously started query, in CSV format.
     *
     * Fetch the data in various formats (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated most with standard Problem Detail reports: - 400 BadRequest : Something failed with the execution of your query - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void fetchQueryResultCsvTest() throws ApiException {
        String executionId = null;
        Boolean download = null;
        String sortBy = null;
        String filter = null;
        String select = null;
        String groupBy = null;
        Integer limit = null;
        Integer page = null;
        String response = api.fetchQueryResultCsv(executionId, download, sortBy, filter, select, groupBy, limit, page);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] FetchQueryResultExcel: Fetches the result from a previously started query, in Excel format.
     *
     * Fetch the data in various formats (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated most with standard Problem Detail reports: - 400 BadRequest : Something failed with the execution of your query - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void fetchQueryResultExcelTest() throws ApiException {
        String executionId = null;
        String sortBy = null;
        String filter = null;
        String select = null;
        String groupBy = null;
        String response = api.fetchQueryResultExcel(executionId, sortBy, filter, select, groupBy);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] FetchQueryResultJson: Fetches the result from a previously started query, in JSON string format.  Please move to &#39;/jsonProper&#39; instead.  This may be marked as Deprecated in the future.
     *
     * Fetch the data in various formats (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated most with standard Problem Detail reports: - 400 BadRequest : Something failed with the execution of your query - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void fetchQueryResultJsonTest() throws ApiException {
        String executionId = null;
        String sortBy = null;
        String filter = null;
        String select = null;
        String groupBy = null;
        Integer limit = null;
        Integer page = null;
        String response = api.fetchQueryResultJson(executionId, sortBy, filter, select, groupBy, limit, page);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] FetchQueryResultJsonProper: Fetches the result from a previously started query, in JSON format.
     *
     * Fetch the data in various formats (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated most with standard Problem Detail reports: - 400 BadRequest : Something failed with the execution of your query - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void fetchQueryResultJsonProperTest() throws ApiException {
        String executionId = null;
        Boolean download = null;
        String sortBy = null;
        String filter = null;
        String select = null;
        String groupBy = null;
        Integer limit = null;
        Integer page = null;
        String response = api.fetchQueryResultJsonProper(executionId, download, sortBy, filter, select, groupBy, limit, page);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] FetchQueryResultPipe: Fetches the result from a previously started query, in pipe-delimited format.
     *
     * Fetch the data in various formats (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated most with standard Problem Detail reports: - 400 BadRequest : Something failed with the execution of your query - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void fetchQueryResultPipeTest() throws ApiException {
        String executionId = null;
        Boolean download = null;
        String sortBy = null;
        String filter = null;
        String select = null;
        String groupBy = null;
        Integer limit = null;
        Integer page = null;
        String response = api.fetchQueryResultPipe(executionId, download, sortBy, filter, select, groupBy, limit, page);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] FetchQueryResultSqlite: Fetches the result from a previously started query, in SqLite format.
     *
     * Fetch the data in various formats (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated most with standard Problem Detail reports: - 400 BadRequest : Something failed with the execution of your query - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void fetchQueryResultSqliteTest() throws ApiException {
        String executionId = null;
        String sortBy = null;
        String filter = null;
        String select = null;
        String groupBy = null;
        String response = api.fetchQueryResultSqlite(executionId, sortBy, filter, select, groupBy);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] GetProgressOf: View progress information (up until this point)
     *
     * View progress information (up until this point) The following error codes are to be anticipated most with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getProgressOfTest() throws ApiException {
        String executionId = null;
        BackgroundQueryProgressResponse response = api.getProgressOf(executionId);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] StartQuery: Starts to Execute HoneycombSql in the background.
     *
     *  Allow for starting a potentially long running query and getting back an immediate response with how to  - fetch the data in various formats (if available, or if not simply being informed it is not yet ready) - view progress information (up until this point) - cancel the query (if still running) / clear the data (if already returned)  This can still error on things like an outright syntax error, but more runtime errors (e.g. from providers) will not cause this to error (that will happen when attempting to fetch data)  Here is an example that intentionally takes one minute to run:  &#x60;&#x60;&#x60;sql select Str, Takes500Ms from Testing1K where UseLinq &#x3D; true and [Int] &lt;&#x3D; 120 &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time) - 401 Unauthorized 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void startQueryTest() throws ApiException {
        String body = null;
        String queryName = null;
        Integer timeoutSeconds = null;
        Integer keepForSeconds = null;
        BackgroundQueryResponse response = api.startQuery(body, queryName, timeoutSeconds, keepForSeconds);

        // TODO: test validations
    }
    
}
